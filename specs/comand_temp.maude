srew in TAS : {(pc[i]: rs) (pc[j]: ws) (locked: b) OCs} using start .
red in TAS : state({(pc[i]: rs) (pc[j]: ws) (locked: b) OCs}) .

red in QLOCK : state({(pc[i]: rs) (pc[j]: ws) (queue: q) OCs}) .
srew in QLOCK : {(pc[i]: rs) (pc[j]: l) (queue: q) OCs} using start .


red in SIM : TAS-inv(tas((locByPid(ws, i) (locByPid(rs, j))), b)) .



red in LOC-BY-PID : locByPid(cs, i) = locByPid(cs, i) .
red in LOC-BY-PIDs : equals((locByPid(cs, i) locByPid(ws, j)), (locByPid(cs, i) locByPid(ws, j))) .
red in LOC-BY-PIDs : equals((locByPid(cs, i) locByPid(ws, j)), (locByPid(ws, j) locByPid(cs, i))) .

red in SIM : r(qlock((locByPid(ws, i) locByPid(rs, j)), Q:Queue{Pid}) ,tas((locByPid(ws, i) (locByPid(rs, j))), B:Bool+)) .
red in SIM : r(qlock((locByPid(rs, j) locByPid(ws, i)), Q:Queue{Pid}) ,tas((locByPid(ws, i) (locByPid(rs, j))), B:Bool+)) .
red in SIM : r(qlock((locByPid(ws, i)), Q:Queue{Pid}) ,tas((locByPid(ws, i) (locByPid(rs, j))), B:Bool+)) .
red in SIM : r(qlock((locByPid(ws, i) locByPid(ws, i) locByPid(rs, j)), Q:Queue{Pid}) ,tas((locByPid(ws, i) locByPid(ws, i) (locByPid(rs, j))), B:Bool+)) .
red in SIM : r(qlock((locByPid(cs, i) locByPid(rs, j)), Q:Queue{Pid}) ,tas((locByPid(ws, i) (locByPid(rs, j))), B:Bool+)) .

red in TAS : getLocByPids(state({(pc[i]: rs) (pc[j]: ws) (locked: b) OCs})) .
red in QLOCK : getLocByPids(state({(pc[i]: rs) (pc[j]: ws) (queue: q) OCs})) .

red in SIM : count((locByPid(cs, i) locByPid(cs, i) locByPid(ws, j)), cs) .

search [1] in TAS : init =>* {(pc[P1]: cs) (pc[P2]: cs) OCs} .
search [1] in TAS : init =>* {OCs} such that not TAS-inv(state({OCs})) .
--- search [1] in TAS : init =>* {(pc[P1]: cs) (pc[P2]: cs) OCs} such that P1 =/= P2 .
--- search [1] in TAS : init =>* {(pc[P1]: L1) (pc[P2]: L2) OCs} such that not ((L1 = cs and L2 = cs) implies P1 = P2) .
--- search [1] in TAS : init =>* {(locked: B) (pc[P1]: L1) (pc[P2]: L2) OCs} such that not TAS-inv(tas(insert(P1, L1, insert(P2, L2, empty)), B)) .
--- search [1] in TAS : init =>* {(locked: B) (pc[P1]: L1) (pc[P2]: L2) OCs} such that not TAS-inv(tas((P1 |-> L1, P2 |-> L2), B)) .

search [1] in QLOCK : init =>* {(pc[P1]: cs) (pc[P2]: cs) OCs} .
search [1] in QLOCK : init =>* {OCs} such that not Qlock-inv(state({OCs})) .

red in QLOCK : getQueue(state({(pc[i]: rs) (pc[j]: ws) (queue: (i | q)) OCs})) .
red in QLOCK : top(getQueue(state({(pc[i]: rs) (pc[j]: ws) (queue: (i | q)) OCs}))) .

red in QLOCK : top(getQueue(state({(pc[i]: rs) (pc[j]: ws) (queue: q) OCs}))) .

red in QLOCK : getLocByPid(getLocByPids(state({(pc[i]: rs) (pc[j]: ws) (queue: q) OCs})), i) .
red in QLOCK : getLocByPid(empty, i) .


red in SIM : r(qlock((locByPid(rs, i) locByPid(l, j)), empq), tas((locByPid(rs, i) locByPid(l, j)), false)) .

red in SIM : getLocByPid(locByPid(rs, i) locByPid(l, j), empq).

red in SIM : getLocByPid(locByPid(rs, i) locByPid(l, j), empq) = rs and false .


red in SIM : r(qlock((locByPid(rs, i) locByPid(l, j)), q), tas((locByPid(rs, i) locByPid(l, j)), false)) .